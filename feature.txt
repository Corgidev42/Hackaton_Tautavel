import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// --- DEFINITION DES COULEURS ET TAILLES ---
const BLOCK_SIZE = { width: 250, height: 60, depth: 250 };
const BLOCK_COLOR = 0x6699ff; // Couleur pour le fil de fer du cube
const EXTRUDE_COLOR = 0xff6644;      
const JAUNE_OS_COLOR = 0xffff66;     // Jaune clair pour l'os
const VERT_SILEX_COLOR = 0x228844;   // Vert pour le silex
const VIOLET_ECLAT_COLOR = 0x9933cc; // Violet pour les éclats
const SCENE_BG_COLOR = 0x111111;
const JAUNE_TERREUX_COLOR = 0x8C8C55;

let scene, camera, renderer, controls, blockMesh; 

function setupScene() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(SCENE_BG_COLOR);
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(400, 400, 400);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(200, 300, 200);
    scene.add(dirLight);
    scene.add(new THREE.AxesHelper(100));
    const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE.width, BLOCK_SIZE.height, BLOCK_SIZE.depth);
    const threshold = 1; 
    const edgesGeo = new THREE.EdgesGeometry(blockGeo, threshold); 
    const edgesMat = new THREE.LineBasicMaterial({ color: BLOCK_COLOR });
    blockMesh = new THREE.LineSegments(edgesGeo, edgesMat);
    scene.add(blockMesh);
    
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

/**
 * Crée une forme extrudée à partir de points 2D, la centre, la tourne et l'ajoute à la scène.
 * @param {Array<{x: number, y: number}>} points2D
 * @param {number} extrusionDepth
 * @param {string} rotationAxis
 * @param {number} rotationAngle
 * @param {string} rotationAxis2
 * @param {number} rotationAngle2
 * @param {number} color
 * @returns {THREE.Mesh}
 */
function createExtrudedShape(
    points2D,
    extrusionDepth = BLOCK_SIZE.height,
    rotationAxis = 'Y', 
    rotationAngle = 0,
    rotationAxis2 = null,
    rotationAngle2 = 0,
    color = EXTRUDE_COLOR 
) {
    if (!scene) {
        console.error("Scene is not set up. Call setupScene() first.");
        return null;
    }

    const shape = new THREE.Shape();
    points2D.forEach((p, i) => i === 0 ? shape.moveTo(p.x, p.y) : shape.lineTo(p.x, p.y));
    shape.closePath();

    const extrudeGeo = new THREE.ExtrudeGeometry(shape, {
        depth: extrusionDepth,
        bevelEnabled: false
    });

    // Centrage de la géométrie
    extrudeGeo.computeBoundingBox();
    const bbox = extrudeGeo.boundingBox;
    
    const centerX = (bbox.max.x + bbox.min.x) / 2;
    const centerY = (bbox.max.y + bbox.min.y) / 2;
    const extrudeHalfDepth = extrusionDepth / 2;

    extrudeGeo.translate(
        -centerX,
        -centerY,
        -extrudeHalfDepth
    );

    // Orientation initiale (pour que le plan XY soit face à l'utilisateur)
    if (rotationAxis === 'Y') {
        extrudeGeo.rotateX(Math.PI / 2);
    } else if (rotationAxis === 'X') {
        extrudeGeo.rotateY(-Math.PI / 2);
    } 

    // Rotations personnalisées
    function applyRotation(geometry, axis, angle) {
        if (axis === 'Y') {
            geometry.rotateY(angle);
        } else if (axis === 'X') {
            geometry.rotateX(angle);
        } else if (axis === 'Z') {
            geometry.rotateZ(angle);
        }
    }
        if (rotationAngle !== 0) {
        applyRotation(extrudeGeo, rotationAxis, rotationAngle);
    }

    if (rotationAxis2 && rotationAngle2 !== 0) {
        applyRotation(extrudeGeo, rotationAxis2, rotationAngle2);
    }

    // Matériau et Maillage
    const extrudeMat = new THREE.MeshStandardMaterial({ color: color });
    const extrudeMesh = new THREE.Mesh(extrudeGeo, extrudeMat);
    
    extrudeMesh.position.set(0, 0, 0); 
    
    scene.add(extrudeMesh);
    
    return extrudeMesh;
}

setupScene();

// ----------------------------------------------------------------------
// DÉFINITIONS ET CRÉATION DES OBJETS
// ----------------------------------------------------------------------

// 1. jaune os
const shapeDefinition = [
    { x: 1.0, y: 1.0 },
    { x: 8.0, y: 2.0 },
    { x: 7.0, y: 7.0 },
    { x: 2.0, y: 6.0 }
];

const angle45 = 12 * Math.PI / 6; 
const angle30 = 67 * Math.PI / 12; 

const extrudedShapeDoubleRot = createExtrudedShape(
    shapeDefinition,
    BLOCK_SIZE.height,
    'Z',
    angle45,
    'X',
    angle30,
    JAUNE_OS_COLOR // COULEUR JAUNE
);

if (extrudedShapeDoubleRot) {
    extrudedShapeDoubleRot.position.set(-30, 13, 30);
}

// 2. jaune ossement (Lame large)
const bladeDefinitionLarge = [
    { x: -1.5, y: -1.3 },
    { x: 7.6, y: -1.4 },
    { x: 1.1, y: 1.3 },
    { x: -1.2, y: 4.5 },
    { x: -2.0, y: 1.8 },
    { x: 1.7, y: -1.38 },
    { x: 2.1, y: 1.4 },
    { x: -1.2, y: 1.1 }
];

const angleX_15 = 17 * Math.PI / 4;
const angleY_90 = 19 * Math.PI / 12;

const largeThickBlade = createExtrudedShape(
    bladeDefinitionLarge,
    5,
    'Y',
    angleX_15,
    'X',
    angleY_90,
    JAUNE_TERREUX_COLOR // COULEUR JAUNE
);

if (largeThickBlade) {
    largeThickBlade.position.set(60, -20, 60);
}

// 3. petit silex couleur verte
const shapeDefinition2 = [
    { x: 1, y: 5 }, 
    { x: 10, y: 6 },
    { x: 8, y: -8 },
    { x: 4, y: -5 },
    { x: -7, y: -5 },
    { x: -5, y: -7 },
    { x: -15, y: 4 },
    { x: -8, y: 10 }
];

const angle45_rad = 2 * Math.PI / 3; 
const angle30_rad =  Math.PI / 6; 

const originalShapeRotated = createExtrudedShape(
    shapeDefinition2,
    3,
    'Y',
    angle45_rad,
    'X',
    angle30_rad,
    VERT_SILEX_COLOR // COULEUR VERTE
);

if (originalShapeRotated) {
    originalShapeRotated.position.set(-60, 30, -60); 
}

// 4. petit eclat couleur violet (Shape 3)
const shapeDefinition3 = [
    { x: 1.1, y: 1.5 }, 
    { x: 3.10, y: 4.6 },
    { x: 1.8, y: -2.8 },
    { x: 2.4, y: -2.5 },
    { x: -2.7, y: -2.5 },
    { x: -2.5, y: -2.7 }
];

const angle45_radI = 2 * Math.PI / 3; 
const angle30_radI =  Math.PI / 6; 

const originalShapeRotated3 = createExtrudedShape(
    shapeDefinition3,
    3,
    'Y',
    angle45_radI,
    'X',
    angle30_radI,
    VIOLET_ECLAT_COLOR // COULEUR VIOLET
);

if (originalShapeRotated3) {
    originalShapeRotated3.position.set(-90, -30, -90); 
}

// 5. petit eclat couleur violet (Shape 4)
const shapeDefinition4 = [
    { x: 2.1, y: 2.5 }, 
    { x: 1.10, y: 1.6 },
    { x: 3.8, y: -3.8 },
    { x: 1.4, y: -1.5 },
    { x: -2.5, y: -2.7 },
    { x: -2.7, y: -2.5 }
];

const angle45_radI4 = 2 * Math.PI / 3; 
const angle30_radI4 =  Math.PI / 6; 

const originalShapeRotated4 = createExtrudedShape(
    shapeDefinition4,
    2,
    'Y',
    angle45_radI4,
    'X',
    angle30_radI4,
    VIOLET_ECLAT_COLOR // COULEUR VIOLET
);

if (originalShapeRotated4) {
    originalShapeRotated4.position.set(-40, 0, -70); 
}


const shapeDefinition5 = [
    { x: 1.2, y: 2.0 }, 
    { x: 2.1, y: 1.5 },
    { x: 3.6, y: -3.4 },
    { x: 3.1, y: -3.3 },
    { x: -2.3, y: -2.8 },
    { x: -1.1, y: -3.8 }
];

const angle45_radI5 = 2 * Math.PI / 3; 
const angle30_radI5 =  19 * Math.PI / 6; 

const originalShapeRotated5 = createExtrudedShape(
    shapeDefinition5,
    2,
    'Y',
    angle45_radI5,
    'X',
    angle30_radI5,
    VIOLET_ECLAT_COLOR // COULEUR VIOLET
);

if (originalShapeRotated5) {
    originalShapeRotated5.position.set(-40, 0, 70); 
}

const shapeDefinition8 = [
    { x: 17.5, y: 14.0 }, 
    { x: 0.0, y: 24.5 },
    { x: -17.5, y: 14.0 },
    { x: -21.0, y: 0.0 },
    { x: -7.0, y: -17.5 },
    { x: 7.0, y: -17.5 },
    { x: 21.0, y: 0.0 }
];

const angle45_radI8 = 9 * Math.PI / 3; 
const angle30_radI8 =  19 * Math.PI / 6; 

const originalShapeRotated8 = createExtrudedShape(
    shapeDefinition8,
    10,
    'Y',
    angle45_radI8,
    'X',
    angle30_radI8,
    EXTRUDE_COLOR
);

if (originalShapeRotated8) {
    originalShapeRotated8.position.set(8, 0, -25);
    originalShapeRotated8.visible = false;
}
const DELAY_MS = 800;

setTimeout(() => {
    if (originalShapeRotated8) {
        originalShapeRotated8.visible = true;
    }
    
    console.log("Objets 7 et 8 affichés après le délai.");
    
}, DELAY_MS);